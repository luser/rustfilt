// Copyright 2016 Mozilla
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#[macro_use]
extern crate clap;
extern crate rustc_demangle;

use rustc_demangle::demangle_stream;

use std::fs::File;
use std::io::{self, stderr, stdin, stdout, BufReader, BufWriter, Write};
use std::path::{Path, PathBuf};
use std::process::exit;
use std::str::FromStr;

mod tests;

enum InputType {
    Stdin,
    File(PathBuf),
}

impl InputType {
    fn demangle(&self, output: OutputType, include_hash: bool) -> io::Result<()> {
        // NOTE: This has to be separated into two functions for generics
        match *self {
            InputType::Stdin => {
                let stdin = stdin();
                let mut lock = stdin.lock();
                output.write_demangled(&mut lock, include_hash)
            }
            InputType::File(ref path) => {
                output.write_demangled(&mut BufReader::new(File::open(path)?), include_hash)
            }
        }
    }
    fn validate(file: String) -> Result<(), String> {
        file.parse::<InputType>().map(|_| ())
    }
}
impl FromStr for InputType {
    type Err = String;
    fn from_str(file: &str) -> Result<InputType, String> {
        if file == "-" {
            Ok(InputType::Stdin)
        } else {
            let path = Path::new(&file);
            if !path.is_file() {
                if !path.exists() {
                    Err(format!("{} doesn't exist", file))
                } else {
                    Err(format!("{} isn't a file", file))
                }
            } else {
                Ok(InputType::File(PathBuf::from(path)))
            }
        }
    }
}

enum OutputType {
    Stdout,
    File(PathBuf),
}

impl OutputType {
    #[inline] // It's only used twice
    fn write_demangled<I: io::BufRead>(&self, input: &mut I, include_hash: bool) -> io::Result<()> {
        match *self {
            OutputType::Stdout => {
                let stdout = stdout();
                let mut lock = stdout.lock();
                demangle_stream(input, &mut lock, include_hash)
            }
            OutputType::File(ref path) => {
                let file = File::create(path)?;
                let mut buf = BufWriter::new(&file);
                demangle_stream(input, &mut buf, include_hash)
            }
        }
    }
    fn write_demangled_names<S: AsRef<str>>(
        &self,
        names: &[S],
        include_hash: bool,
    ) -> io::Result<()> {
        #[inline] // It's only used twice ;)
        fn demangle_names_to<S: AsRef<str>, O: io::Write>(
            names: &[S],
            output: &mut O,
            include_hash: bool,
        ) -> io::Result<()> {
            for name in names {
                let demangled = rustc_demangle::demangle(name.as_ref());
                if include_hash {
                    writeln!(output, "{}", demangled)?
                } else {
                    writeln!(output, "{:#}", demangled)?
                };
            }
            Ok(())
        }
        match *self {
            OutputType::Stdout => {
                let stdout = stdout();
                let mut lock = stdout.lock();
                demangle_names_to(names, &mut lock, include_hash)
            }
            OutputType::File(ref path) => {
                let file = File::create(path)?;
                let mut buf = BufWriter::new(&file);
                demangle_names_to(names, &mut buf, include_hash)
            }
        }
    }
    fn validate(file: String) -> Result<(), String> {
        file.parse::<OutputType>().map(|_| ())
    }
}
impl FromStr for OutputType {
    type Err = String;
    fn from_str(file: &str) -> Result<OutputType, String> {
        if file == "-" {
            Ok(OutputType::Stdout)
        } else {
            let path = Path::new(&file);
            if path.exists() {
                Err(format!("{} already exists", file))
            } else {
                Ok(OutputType::File(PathBuf::from(path)))
            }
        }
    }
}

fn main() {
    let args: clap::ArgMatches = clap_app!(rust_demangle =>
        (version: crate_version!())
        (author: crate_authors!())
        (about: "Demangles names generated by the rust compiler")
        (@arg INCLUDE_HASH: --include-hash --hash "Include the hashes in the demangled names")
        (@arg INPUT: --input -i [FILE] default_value("-") {InputType::validate} "The input file to replace the mangled names in, or '-' for stdin")
        (@arg OUTPUT: --output -o [FILE] default_value("-") {OutputType::validate} "The output file to emit the demangled names to, or '-' for stdout")
        (@arg NAMES: ... [NAME] conflicts_with[INPUT] "The list of names to demangle")
    ).get_matches();
    let include_hash = args.is_present("INCLUDE_HASH");
    let output = value_t!(args, "OUTPUT", OutputType).unwrap();
    if let Some(names) = args.values_of("NAMES") {
        output
            .write_demangled_names(&names.collect::<Vec<_>>(), include_hash)
            .unwrap_or_else(|e| {
                writeln!(stderr(), "Unable to demangle names: {}", e).unwrap();
                exit(1);
            })
    } else {
        let input = value_t!(args, "INPUT", InputType).unwrap();
        input.demangle(output, include_hash).unwrap_or_else(|e| {
            writeln!(stderr(), "Unable to demangle input: {}", e).unwrap();
            exit(1);
        })
    }
}
